## 第十一章--安全管理

### 安全控制概述

- 安全性：保护数据，以防止**不合法用户**故意造成的破坏
- 完整性：保护数据，以防止**合法用户**无意中造成的破坏

#### 授权和认证

授权是将访问数据库或数据库对象的权限赋予用户的过程

认证是一种鉴定用户身份的机制

现在DBMS的授权规则一般为：

- 自主存取控制：用户对不同的数据对象具有不同的存取权限，而且没有固定的关于哪些用户对哪些存取权限的限制。非常灵活
- 强制存取控制：每一个数据对象都被标以一定的密级，每个用户也被授予一个许可证级别。对于任意对象，只有合法许可证的用户，才可以存取

### 存取控制

#### 自主存取控制

##### 权限种类：

1. 语句权限
   - CREATE DATABASE
   - CREATE TABLE 
   - CREATE VIEW
   - CREATE PROCEDURE：具有在数据库中创建存储过程的权限
2. 对象权限
   - DELETE,INSERT,UPDATE,SELECT：其中UPDATE和SELECT可以对表的单个列进行授权
   - EXECUTE：具有执行存储过程的权限
   - REFERENCES：具有通过外键引用其他表的权限

##### 数据库用户分类：

- 系统管理员：拥有全部权限
- 数据库对象拥有者：创建数据库对象的用户为数据库对象用户者，其对其所拥有的对象具有全部权限
- 普通用户：只有对数据库数据的增、删、查、改权限

权限一般分为对象权限、语句权限和隐含权限，其中对象权限是可以被授予的数据库权限，隐含权限是用户自动具有的权限。

##### 权限管理语句

- GRANT：授予权限
- REVOKE：收回权限
- DENY：拒绝某用户具有的某种操作权限

###### 对象权限

授权

``` sql
GRANT 对象权限名 [,..] ON {表名|视图|存储过程名}
	TO 用户名 [,..]
	[WITH GRANT OPTION]
```

`WITH GRANT OPTION`表示被授权的用户还可以把其授权转给其他用户

收权

``` sql
REVOKE 对象权限名 [,..] ON {表名|视图|存储过程名}
	FROM 用户名 [,..]
```

拒绝权限

``` sql
DENY 对象权限名 [,..] ON {表名|视图|存储过程名}
	TO 用户名 [,..]
```

其中对象权限为：

- 对表和视图是INSERT,DELETE,UPDATE,SELECT权限
- 对存储过程是EXECUTE权限

###### 语句权限

授权

``` sql
GRANT 语句权限名 [,..] TO 用户名 [,..]
	WITH GRANT OPTION
```

收权

``` sql
REVOKE 语句权限名 [,..] FROM 用户名 [,..]
```

拒绝权限

``` sql
DENY 语句权限名 [,..] TO 用户名 [,..]
```

#### 强制存取控制

因为自由存取控制下，用户可以自由的将权限转授，可能会存在数据的“无意泄露”。造成这一问题的根本原因是数据本身没有安全性标记。

要解决这个问题，**必须对系统下的所有主客体实施强制存取控制策略**

- 主体是系统的活动实体：既包括DBMS管理系统的实际用户，也包括代表用户的各个进程
- 客体是系统的被动实体，是收主体控制的，包括文件、基本表、索引、视图等
- 对于主体和客体，DBMS给他们每个实例指派一个敏感度标记（Label）

主体的敏感度标记被称为许可证级别，客体的敏感度级别被称为密级

**强制存取控制就是对比主体的Label和客体的Label，最终来确认主体能否存取客体**

当某一用户以标记Label注册到系统时，系统要求他对任何客体的存取必须满足以下规则：

- 仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体
- 仅当主体的许可证级别等于客体的密级时，该主体才能写相应的客体

**保证了用户可以写入数据，但一旦写入数据就不能再读取该数据对象了**

**较高的安全性级别提供的安全保护要保护较低级别的所有保护。**

因此，实现强制存取控制时要先实现自主存取控制

### 审计跟踪

是一种特殊文件或数据库，系统上自动记录下用户对常规数据的所有操作。

### 防火墙

是用来防止来自专业网的非法访问或对专用网的非法访问而设计的一个系统

- 数据包过滤
- 应用级网关
- 电路级网关
- 代理服务器

### 统计数据库的安全性

### 数据加密

### SQL Server提供的安全控制

1. 确认用户是否为数据库服务器的合法用户
2. 确认用户是否是要访问的数据库的合法用户
3. 确认数据库是否具有合适的操作权限

## 第十二章--事务与并发控制

事务是保护数据一致性的基本手段

### 事务

是数据库处理的一个逻辑工作单元，由用户业务定义的一个或多个访问数据库的操作组成，这些操作一般包括检索、插入、删除和修改数据。

**一个事务内的所有语句视为一个总体，要么全部执行，要么全部不执行**

事务结束的标志：

- COMMIT：正常结束，事务的所有操作都会物理地保存到数据库中
- ROLLBACK：异常结束，事务的所有操作被撤销，数据库回到事务开始前的状态

#### 事物的特性（AICD）

1. 原子性
2. 一致性
3. 隔离性
4. 持久性

事务是数据库并发控制和恢复的基本单元。可能对AICD造成破坏的因素有：

1. 多个事务并行运行时，不同事务的操作有交叉情况
2. 事务在运行过程被强迫停止

针对1，数据库管理系统必须保证多个事务在交叉运行时不影响这些事务的原子性

针对2，数据库管理系统必须保证被强迫终止的事务对数据库和其他事务没有任何影响

#### 事务处理模型

当用户进行一个事务后，他必须连续地执行全部后续的SQL语句，直到出现以下4个事件之一

- 达到了一个COMMIT语句
- 达到了一个ROLLBACK语句
- 成功达到了程序的结束
- 程序被异常终止了

事务有两种类型：

- 显式事务：指每一条数据操作语句都自动地成为一个事务

- 隐式事务：是有显式的开始和结束标志的事务

  - ISO的事务处理模型

  ``` sql
  UPDATE 账户表 SET 账户金额=账户金额-2000
  	WHERE 账户号='A'
  UPDATE 账户表 SET 账户金额=账户金额+2000
  	WHERE 账户号='B'
  COMMIT
  ```

  - T-SQL的事务处理模型

  ``` sql
  BEGIN TRANSACTION
  UPDATE 账户表 SET 账户金额=账户金额-2000
  	WHERE 账户号='A'
  UPDATE 账户表 SET 账户金额=账户金额+2000
  	WHERE 账户号='B'
  COMMIT
  ```

T-SQL事务开始语句

``` sql
BEGIN TRAN[SACTION] [事务名]
```

#### 事务日志

DBMS对数据库所做的每个更改都维护一个事务记录，并保存到事务日志中。

事务日志一般记录下列信息：

- 事务的开始标志
- 事务标识符
- 操作的记录标识符
- 在记录上的操作（如插入、删除和修改）
- 数据被修改前的值
- 记录被更改后的值
- 如果事务被提交时的事物的制造者

### 并发控制

如果数据库的管理系统可以同时接收多个事务，且这些事务在时间上可以相互重叠执行，则称这种执行方式为并发执行。

并发操作带来的数据不一致分为以下四种：

**数据丢失**

| 时间  |         事务$T_1$          |                    事务$T_2$                     |
| :---: | :------------------------: | :----------------------------------------------: |
| $t_1$ |           读A=16           |                                                  |
| $t_2$ |                            |                      读A=16                      |
| $t_3$ | 计算A=A-1=15<br />写回A=15 |                                                  |
| $t_4$ |                            | 计算A=A-4=12<br />写回A=12(覆盖了$T_1$对A的修改) |

**读脏数据**

| 时间  |                事务$T_1$                 |          事务$T_2$           |
| :---: | :--------------------------------------: | :--------------------------: |
| $t_1$ | 读B=16<br />计算B=B*2=200<br />写回B=200 |                              |
| $t_2$ |                                          | 读B=200(读入$T_1$的“脏数据”) |
| $t_3$ |         ROLLBACK<br />B恢复为100         |                              |

**不可重复读**

| 时间  |                         事务$T_1$                          |                 事务$T_2$                 |
| :---: | :--------------------------------------------------------: | :---------------------------------------: |
| $t_1$ |            读A=50<br />读B=100<br />求和A+B=150            |                                           |
| $t_2$ |                                                            | 读B=100<br />计算B=B*2=200<br />写回B=200 |
| $t_3$ | 读A=50<br />读B=200<br />求和A+B=250(与第一次统计的值不同) |                                           |

**产生“幽灵数据”**

#### 可交换的活动

- 读-读：可交换
- 读-写：不可交换
- 写-写：不可交换

#### 调度

是一个活动或操作序列，这个序列由事务集合的活动及事务内部活动的顺序构建

降低了处理效率，但是可以解决之前的问题

#### 可串行调度

目的是安排或调度事务操作的执行顺序，以避免它们之间的相互干扰，以串行方式顺序执行和提交事务可以达到这个目的。

可串行调度的规则是：

- 如果事务$T_1$和$T_2$只是读数据项，则它们没有冲突，执行顺序不重要
- 如果事务$T_1$和$T_2$在读或写的是完全不同的数据项，则它们没有冲突，执行顺序不重要
- 如果事务$T_1$是写数据，而$T_2$读或是写相同的数据项，则执行顺序很重要

### 并发控制中的加锁方法

在数据库中环境中，进行并发控制的主要方式就是实时封锁机制，即加锁（Locking）

具体的控制权由锁决定，锁分为两种：排它锁（X锁）和共享锁（S锁）

- 共享锁：若事务T给数据项A加了S锁，则事务T可以读A,但不能修改A，其他事务可以再给A加S锁，但不能加X锁，直到T释放了A上的S锁为止。
- 排它锁：若事务T给数据A项加了X锁，则允许T读取和修改A，但不允许其他事务再加任何类型的锁和进行任何类型的操作
- 如果事务$T_1$在数据项A上加了S锁，则允许$T_2$在A上加S锁请求，即允许其他事务对A再加S锁。即读-读是可交换的
- 如果事务$T_1$在数据项A上加了S锁，则拒绝$T_2$在A上加X锁请求，即不允许其他事务对A再加X锁。即读-写是不可交换的
- 如果事务$T_1$在数据项A上加了X锁，则拒绝$T_2$在A上加任何锁的请求，即不允许其他事务对A再加任何锁。即写-写是不可交换的

#### 锁的粒度

由并发控制程序选择的作为保护单位的数据项的大小被称为粒度

粒度是由并发控子系统控制的独立数据单位，基于锁的并发控制机制中，粒度是一个可加锁单位。

通常锁的粒度是数据页

锁的加锁粒度：

- 数据库级
- 表级
- 页级
- 行（元组）级
- 属性（字段）级

##### 数据库级锁

在某个事务执行期间，将防止任何其他事务使用的数据库中的任何表

##### 表锁级

在某个事务执行使用这个表期间，将防止任何其他事务使用的表中数据

##### 页级锁

一个表可以跨越多个页，最适合多用户数据库管理系统使用

##### 行级锁

##### 属性级锁

#### 封锁协议

一级封锁协议:对事务T要修改的数据加X锁，直到事务结束时才释放

在一级封锁协议中，如果T只读取数据，不对其进行修改，则不需要加锁。

**因此不能保证可重复读和不读“脏数据”**

二级封锁协议：在一级封锁协议的基础上，增加事务T对要读取的数据加S锁，读完后即释放S锁

**不能保证可重复读数据**

三级封锁协议：在一级封锁协议的基础上，增加事务T对要读取的数据加S锁，并直到事务结束才释放

**三级封锁就可以避免以上那些问题**

#### 活锁和死锁

避免活锁的最优策略为**先来先服务**

当多个事务请求封锁相同数据项时，数据库管理系统应按先请先满足的事务排队策略。

当数据项上的封锁被释放了，让事务队列中第一个事务获得锁

**预防死锁**

- 一次封锁法：每个事务一次将所有要运行的数据项全部加锁，否则不能继续执行
- 顺序封锁法：预先对数据项规定一个封锁顺序，所有事务都按照这个顺序封锁

**死锁的诊断与解除**

- 超时法
- 事务等待图法

#### 两阶段锁

在两阶段锁中，所有的加锁操作都在第一个解锁操作之前完成

三阶段：

1. 加锁阶段：在这个阶段事务获得锁所有需要的锁，且不释放任何锁
2. 持锁阶段：在这个阶段事务不加锁也不释放任何锁
3. 解锁阶段：在这个阶段事务释放全部的锁，且不获得任何新锁

事务遵守两阶段锁协议是可串行化调度的充分条件，而不是必要条件

### 乐观的并发控制方法

基于假设数据库操作的冲突是很少的，而且最好是让事务完全执行并只在事务提交前检查冲突

- 读阶段
- 验证阶段或确认阶段
- 写阶段

[乐观并发控制详解-CSDN博客](https://blog.csdn.net/qq_32165041/article/details/83041553)